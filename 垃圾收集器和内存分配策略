1.	判断哪些内存需要回收
（1）	判断对象是否还存活，有两种方法
引用计数法：给对象添加一个引用计数器，每增加一个该对象得引用，一直到该对象的引用为0时才回收它。
           当存在两个对象互相引用时，引用计数法可能导致这两个对象永远无法回收，所以java虚拟机采用的并不是引用计数法。
可达性分析法：从任意GC roots节点开始，依此遍历，若是有引用链相连，就是可达的，若是没有引用链相连，就是不可达的。
           不可达的节点就是可回收的对象。可以做为GCroots的对象包括，虚拟机栈中引用的对象，方法区中静态属性类引用的对象，本地方法栈中引用的对象。
           但是需要注意的是不可达对象也不是非死不可的，因为宣判一个对象不可用，至少要经历两次标记过程：
           第一次经过可达性分析之后，如果发现不可达就会被标记和筛选，筛选的条件是看你是否需要执行finalize()方法，
           如果没有覆盖这个方法或者已经调用过了，就不用执行，就可以回收掉了。
           如果需要执行，就把这个对象加入一个F-queue队列中，稍后由虚拟机的一个专门的线程执行，
           如果对象再finalize（）方法中完成了自救就不会被回收，如果没有的话就会被回收。第二次标记的时候，如果这些对象还在即将回收的集合里，就真的会被回收。
（2）	判断方法区中的常量和类是否可回收。
     废弃常量：没有任何对象引用常量池中的常量，也没有任何字面量是这个常量，这个常量就是废弃常量，可被回收。
类的回收：该类的所有对象都已经被回收。加载该类的ClassLoader被回收。也无法在任何地方通过反射访问该类。满足着三个条件，这是可回收类。

2.	垃圾收集算法‘
（1）	标记-消除算法
这种算法是指使用一半的内存区域，把内存区域标记为存活对象，可回收对象和未使用区域。
Gc操作发生时就把内存区域标记为可回收的给回收掉。
这种算法会产生很多的碎片，可能导致需要分配一大块存储空间的时候无法分配连续存储空间，而不得不提前促发一次gc操作。
（2）	复制算法
复制算法是队标记消除算法的改进，它只使用了一半的存储空间，当gc操作发生时，把存活对象全部复制到未使用的那一半区域，然后把正在使用的这一半区域清除掉。
这样虽然不会产生内存碎片但是只有效利用了一半的存储区域。现在的商业虚拟机的新生代都是采用的这种算法，但是不是采用1:1的比例，而是Eden空间和survivor空间8：1的比例，有两个survivor空间和一个Eden空间，对象一般都是在Eden空间创建，每次把存活的对象移到未使用的survivor空间，如果survivor空间不够，就移到老年代空间，这就是空间担保，后面会介绍。所以这种算法的空间利用率时90%。
（3）	标记-整理算法
标记整理算法也是对标记-整理算法的改进，它解决了复制算法空间利用率的问题。每次gc操作是把存活对象放到内存区域的一端，然后清除这个边界以外的其它区域。老年代使用的就是标记整理算法。
（4）	分代收集算法
当代商业虚拟机采用的都是分代收集算法，就是把堆划分为新生代和老年代，新生代每次都有大批的对象死去，所以采用复制算法，有老年代的空间作为担保，而老年代对象存活率高，也没有额外空间做担保，必须使用标记-清理或者标记整理算法。
3.	内存分配与回收策略
（1）	内存分配
对象优先分配在新生代的Eden区域上，如果开启了本地线程分配缓冲，将按线程优先分配在TABLE上，TABLE是为了解决指针移动时线程不安全的问题，减少了同步锁的使用。大对象直接进入老年代。长期存活的对象进入老年代。
（2）	动态年龄判定
除了年龄达到设定的值外，相同年龄的所有对象的大小，超过了survivor空间的一半的时候，也会让超过该年龄的对象进入老年代。
（3）	空间分配担保
当进行Minor GC之前，会检查老年代的最大连续空间是否大于新生代所有对象的空间，如果不大于，就要检查HandlePromotionFailue设置值时否允许担保失败，如果允许，则继续检查老年代的最大连续空间是否大于历代升入老年代的对象的平均值，若大于则可以冒险一次，失败了再进行Full GC。
Full GC比Minor GC要慢10倍以上，所以要避免频繁Full GC.
4.	 垃圾收集器
(1)	Serial收集器
新生代收集器，采用单线程收集器，采用复制算法，也就是收集时会把其它的用户线程都停止掉，单线程效率高。
(2)	Parnew收集器
新生代收集器，与Serial收集器的区别就是，收集时可以多线程同时收集，但是也要停止用户线程。
(3)	Parallel scavenge收集器
新生代收集齐，也是多线程的，复制算法收集器，但是它关注的是吞吐量。
(4)	Serial Old收集器
老年代收集器，单线程，采用标记-整理算法。
(5)	Parallel old收集器
老年代收集器，多线程，标记-整理，吞吐量优先
(6)	CMS收集器
CMS收集器以最短停顿时间为目标的一个收集器，使用标记-清理算法它分为四步：
第一步：初始化标记，这一步是会停止所有用户线程的，但是只标记和GCroots直接相连的节点，所以时间短，就是停顿时间短。
第二步：并发标记，这一步是不用停止所有用户线程的，标记所有的的对象，但是因为用户线程再运行，可能会改变原来的对象状态，所以有要进行第二次标记。
第三步：重新标记，这一步是会停止所有用户线程的，这一步是重新标记在并发标记过程中，状态改变的对象，时间会比并发标记短很多，所以停顿时间短。
第四步：并发清理，这一步不会停止用户线程
CMS收集器的缺点：
第一，	对CPU资源敏感，占用了一部分线程，可能会导致程序变慢。
第二，	因为是并发清理，所以无法清理在并发清理过程中产生的浮动垃圾。
第三，	使用的标记-清理算法，可能会产生内存碎片。
(7)	G1收集器
面向服务端应用的收集器，标记整理算法，可预测的停顿，并行和并发，可以使用多个CPU来缩短停顿时间。分为如下四步：
第一，	初始标记
第二，	并发标记
第三，	最终标记
第四，	筛选回收
