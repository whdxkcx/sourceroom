1.	判断哪些内存需要回收
（1）	判断对象是否还存活，有两种方法
引用计数法：给对象添加一个引用计数器，每增加一个该对象得引用，一直到该对象的引用为0时才回收它。当存在两个对象互相引用时，引用计数法可能导致这两个对象永远无法回收，所以java虚拟机采用的并不是引用计数法。
可达性分析法：从任意GC roots节点开始，依此遍历，若是有引用链相连，就是可达的，若是没有引用链相连，就是不可达的。不可达的节点就是可回收的对象。可以做为GCroots的对象包括，虚拟机栈中引用的对象，方法区中静态属性类引用的对象，本地方法栈中引用的对象。
（2）	判断方法区中的常量和类是否可回收。
     废弃常量：没有任何对象引用常量池中的常量，也没有任何字面量是这个常量，这个常量就是废弃常量，可被回收。
类的回收：该类的所有对象都已经被回收。加载该类的ClassLoader被回收。也无法在任何地方通过反射访问该类。满足着三个条件，这是可回收类。

2.	垃圾收集算法‘
（1）	标记-消除算法
这种算法是指使用一半的内存区域，把内存区域标记为存活对象，可回收对象和未使用区域。Gc操作发生时就把内存区域标记为可回收的给回收掉。这种算法会产生很多的碎片，可能导致需要分配一大块存储空间的时候无法分配连续存储空间，而不得不提前促发一次gc操作。
（2）	复制算法
复制算法是队标记消除算法的改进，它只使用了一半的存储空间，当gc操作发生时，把存活对象全部复制到未使用的那一半区域，然后把正在使用的这一半区域清除掉。这样虽然不会产生内存碎片但是只有效利用了一半的存储区域。现在的商业虚拟机的新生代都是采用的这种算法，但是不是采用1:1的比例，而是Eden空间和survivor空间8：1的比例，有两个survivor空间和一个Eden空间，对象一般都是在Eden空间创建，每次把存活的对象移到未使用的survivor空间，如果survivor空间不够，就移到老年代空间，这就是空间担保，后面会介绍。所以这种算法的空间利用率时90%。
（3）	标记-整理算法
标记整理算法也是对标记-整理算法的改进，它解决了复制算法空间利用率的问题。每次gc操作是把存活对象放到内存区域的一端，然后清除这个边界以外的其它区域。老年代使用的就是标记整理算法。
（4）	分代收集算法
当代商业虚拟机采用的都是分代收集算法，就是把堆划分为新生代和老年代，新生代每次都有大批的对象死去，所以采用复制算法，有老年代的空间作为担保，而老年代对象存活率高，也没有额外空间做担保，必须使用标记-清理或者标记整理算法。
3.	内存分配与回收策略
（1）	内存分配
对象优先分配在新生代的Eden区域上，如果开启了本地线程分配缓冲，将按线程优先分配在TABLE上，TABLE是为了解决指针移动时线程不安全的问题，减少了同步锁的使用。大对象直接进入老年代。长期存活的对象进入老年代。
（2）	动态年龄判定
除了年龄达到设定的值外，相同年龄的所有对象的大小，超过了survivor空间的一半的时候，也会让超过该年龄的对象进入老年代。
（3）	空间分配担保
当进行Minor GC之前，会检查老年代的最大连续空间是否大于新生代所有对象的空间，如果不大于，就要检查HandlePromotionFailue设置值时否允许担保失败，如果允许，则继续检查老年代的最大连续空间是否大于历代升入老年代的对象的平均值，若大于则可以冒险一次，失败了再进行Full GC。
Full GC比Minor GC要慢10倍以上，所以要避免频繁Full GC.
