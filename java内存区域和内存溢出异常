为什么要了解java内存，因为程序要把内存的分配和回收都交给了java虚拟机，所以，如果不了解java虚拟机是如何是内存的，当出现问题是，排除错误将是一件很艰难的错误。
1.	java运行时区域
（1）	程序计数器
程序计数器时一块较小的内存，是程序所执行的字节码的行号指示器。字节码解释器工作时就是通过这个计数器来选取下一条要执行的指令。为了线程切换后能够恢复到正常位置，每个线程都有一个单独的程序计数器。各个线程之间的程序计数器时互不干扰的，运行java方法时，程序计数器存放的就是正在执行的字节码的地址。运行本地方法时为空。
     (2)   虚拟机栈（VM stack）
与程序计数器一样，java虚拟机栈也是线程私有的，它的生命周期和线程同步。它描述的java方法的内存模型，每个java方法执行的时候都会创建一个栈帧，这个栈帧用于存储局部变量表，操作数栈，方法出口等信息，每个方法在执行到完成的过程就是一个栈帧在虚拟机栈种进栈到出栈的过程。
其中需要特殊注意的时栈帧中的局部变量表，它存储了基本类型变量和引用。double和long占用了两个局部变量空间，其它只占一个，而且方法执行过程中。
当线程请求的虚拟机栈深度超出了允许的最大深度，就会报StackOverflowError异常。有动态扩展的功能，自动扩展时无法申请到足够的内存，就会报OutOfmemoryError异常。
（3）本地方法栈
     本地方法栈和虚拟机栈类似，只不过本地方法栈时针对本地方法的。
（4）java堆
  Java堆时所有线程共享的一块区域，也是大部分java应用最大的一块程序，java中所有的堆和数组都时在这上面分配的，gc操作也基本上都发生在这个区域。所以也成为gc堆。当内存没有完成实例分配，也无法扩展的时候，就会报OutOfmemoryError异常。新生代和老生待也是在堆中分的。
（5）方法区
  方法区是存放虚拟机加载的类信息，常量，静态变量，即时编译编译后的代码等。它hotSpot把GC分代收集管理扩展自方法去，用java自动内存管理来管理。方法区无法满足内存分配的时候也会报出OutOfmemoryError异常。
（6）运行时常量池
运行时常量池时方法区的一部分，class文件中的常量池的信息在类加载以后会被放到方法区的运行时常量池中。而且这个常量池时可以动态加载的。当然方法区的东西，肯定在内存不足时报OutOfmemoryError异常.

2.	java对象在内存的创建，布局和定位
（1）	java对象的创建
当虚拟机遇到一条new指令的时候，首先会去常量池中看能否定位到一个符号引用，并检查这个类是否被加载，解析和初始化过，如果没有就要执行相应的加载过程。加载之后就是为对象分配内存，有两种分配方法，如果堆是齐整的就会采用“指针碰撞”法，如果不齐整就会采用“空闲列表”法。而是否齐整又是由所采用的垃圾收集过程时候带有功能决定。Serial，ParNew等带压缩，CMS不带。
       因为对象创建时很频繁的行为所以还要考虑修改指针时的线程安全问题。有一种本地线程缓冲方案比较不错。
（2）	java对象的内存布局
对象在内存中存布局可以分为3块区域：对象头，实例数据和对齐填充。
对象头分为两部分信息，一部分时自身运行信息，如hash码等，一部分时类型指针，指向对应它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
实例数据是真正存储有效信息，如对象的字段内容，其存储顺序会受虚拟机分配策略和java中源码定义的顺序影响。
第三部分对齐填充不是必然存在的。
（3）	对象的访问定位
在java虚拟机栈的栈帧的局部变量表中，只存储了一个引用，要根据这个引用去定位对象在堆中的位置。目前主流的有两种方法，一种是句柄定位，一种是直接指针。
句柄定位就是java虚拟机会在堆中划分出一个句柄池，存储对象在堆中的地址和对象对应的类的元数据在方法区中存放的地址。栈帧中存放对象地址在句柄池中的位置。
直接指针就是在栈帧中存放对象在堆中的地址，而堆中除了存放实例信息之外还存放了类型信息在方法区中的存放地址。
句柄的优势在于稳定，对象修改也只用修改句柄池的信息，而栈帧中 的信息不用修改。
直接指针的优势在于访问速度快。

3.	内存溢出
内存溢出包括java堆溢出，虚拟机和本地方法栈溢出，方法区和运行时常量池溢出以及本机直接内存溢出。
 
           
